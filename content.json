{"posts":[{"title":"hexo + icarus + github搭建博客系统","text":"搭建博客很久前都想要搭建一个博客系统了，但是由于各种事情没有落实下来——其实更多的是自己的 “拖延症” 造成的嘻嘻~。秋招的时候被面试官问到有没有写博客，这更加刺激了我要写博客的想法，感觉那些优秀的人充分地利用了自己的时间，并且坚持专注于一个领域的学习和积累。现在工作和论文两座大山已经从我身上移开，入职前的空档期可以开心地去做自己喜欢做的事情，比如搭建个博客吧 ~ 搭建过程选用开源的博客系统hexo搭建，部署在github上，可以通过&lt;用户名&gt;.github.io进行访问，除了速度有些慢之外其它方面还OK，毕竟是免费嘛哈哈~ 1.安装Git和node.js首先下载安装git和nodejs在windows系统上安装这两个软件很简单，点下一步即可（注意：window7不支持node最新版本14，我安装的12） 2.安装并初始化hexo使用npm命令下载安装Hexonpm install hexo -g //全局安装hexo新建一个文件夹存放hexo项目文件，切换目录至新建好的空文件夹下执行以下命令hexo init //初始化 执行完成后当前目录下会生产以下文件，其中需要用到的是_config.yml文件以及theme文件夹。轻松可以想到_config.yml是用来对hexo进行配置，theme是用来设置博客的主题。 紧接着执行命令： npm install //安装相关依赖 3.部署至github首先在_config.yml文件中找到deploy字段，替换成自己的github仓库地址。如下： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/zhangkaien/zhangkaien.github.io.git branch: master 接着打开Git Bash,切换目录至hexo根目录，执行以下命令：npm install hexo-deployer-git --save //局部安装部署依赖 12hexo clean //清理hexo deploy //部署 上传之后就可以通过 &lt;用户名&gt;.github.io 来访问了，可能会有些延迟，等待几分钟即可。也可以通过以下命令预览，默认端口为4000，即通过localhost:4000访问。hexo s //启动本地服务器进行预览 部署上传过程中需要输入账号密码挺麻烦，可以配置SSH免密访问。github—配置SSH访问设置之后仍需要账号密码解决方案：（方法1）windows下添加github账号密码或 （方法2）更改配置文件中仓库地址 更换主题1. icarus主题我选择icarus的两个理由：1.hexo默认的主题没有分类的功能2.icarus比较简洁漂亮 hexo系统设置icarus主题方法 2. 踩到的坑 &lt;!--more--&gt;语句不能出现在文章的开头，否则无效，也就是说&lt;!--more--&gt;前边必须有文章的正文。 提交时要重新生成,命令为：12hexo ghexo d 也可以使用组合命令代替：hexo d -g 感受刚开始还是不太习惯Markdown语法，可能熟练之后才能体会到它的方便和强大吧。另外博客搭建好之后，要督促自己经常写博客，一是提高自己的书写能力，养成清晰的逻辑思维；而是将平时的所学所见所思记录下来，汇点滴成汪洋。最后祭上我的新头像 ^ . ^ End~","link":"/2020/04/25/first-page/"},{"title":"angular 路由缓存","text":"前言平时开发可能会有这样的需求： 用户在页面切换路由时候，并不想重新请求后端数据渲染，提高页面性能 在下钻到二级页面后切换回来，想要保留上次的滚动条记录，避免用户再次锚定信息位置，提升用户体验 之前团队都是使用变量或者浏览器存储来解决上面提到的需求2，逻辑比较繁杂，对业务代码侵入较大，且没有满足需求1，偶然看到angular提供了路由缓存的功能，可以满足上面两个需求。下面就记录一下路由缓存的使用。 引入配置angular提供了缓存策略接口 RouteReuseStrategy, 可以创建一个实现该接口的类: 123export class MyReuseStrategy implements RouteReuseStrategy { ...} 然后在根模块配置中将路由缓存策略替换成我们自己的: 1234providers: [ { provide: RouteReuseStrategy, useClass: MyReuseStrategy }] 使用路由缓存下面是完整的自己设置的路由缓存类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import {ActivatedRouteSnapshot, DetachedRouteHandle, RouteReuseStrategy} from '@angular/router';export class MyReuseStrategy implements RouteReuseStrategy{ // 缓存map需要自己维护 public static handlers:{[key: string]: DetachedRouteHandle} = {} // 删除缓存 public static deleteRouteSnapshot(path: string): void { const name = path.replace(/\\//g, '_') if(MyReuseStrategy.handlers[name]) { delete MyReuseStrategy.handlers[name] } } // shouldAttach返回true时被调用，从缓存里取出来加载，实现缓存的复用 retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null { console.log(&quot;######retrieve&quot;); return MyReuseStrategy.handlers[this.getUrl(route)] } // 在这里判断是否要从缓存里加载当前路由的组件，逻辑是只要我们的缓存里有，就返回true shouldAttach(route: ActivatedRouteSnapshot): boolean { console.log(&quot;######shouldAttach&quot;); return !!MyReuseStrategy.handlers[this.getUrl(route)]; } // 可以在这里判断是否进行路由缓存 shouldDetach(route: ActivatedRouteSnapshot): boolean { console.log(&quot;######shouldDetach&quot;); return !(route['_routerState'].url === '/route'); } // 判断是否进入shouldAttach 和 shouldDetach // 根路由出发一次 其它触发两次，这块没有搞明白为什么这样做 // 一般这样配置 return future.routeConfig === curr.routeConfig; 猜测只要有一次返回true就可以了，如此就可以设置根路由是否缓存 shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean { console.log(&quot;######shouldReuseRoute ===&gt; &quot;, future.routeConfig === curr.routeConfig); return future.routeConfig === curr.routeConfig; } // 若shouldDetach返回true， store方法被调用，用来存储加载过的路由组件 store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void { console.log(&quot;######store&quot;); if(!MyReuseStrategy.handlers[this.getUrl(route)]) { MyReuseStrategy.handlers[this.getUrl(route)] = handle } } // 用到了route里的字段route['_routerState'].url，把 / 替换成 _，作为map的key getUrl(route: ActivatedRouteSnapshot): string { return route['_routerState'].url.replace(/\\//g, '_') }} 当第一次进入页面，路由为/： 首先shouldReuseRoute返回true，方法继续往下面调用接着先从缓存里读取，如果返回null，则初始化组件然后 shouldAttach 判断是否命中缓存，这里刚进来，所以方法到这里就结束了 当切换到/route路由时： 调用逻辑：shouldReuseRoute -&gt; retrieve -&gt; shouldDetach(是否缓存刚离开的路由) -&gt; store(存储路由缓存) -&gt; shouldAttach（是否命中当前路由的缓存） 再切回/路由时： 调用逻辑：shouldReuseRoute -&gt; retrieve -&gt; shouldDetach(是否缓存刚离开的路由) -&gt; store(存储路由缓存) -&gt; shouldAttach（是否命中当前路由的缓存）-&gt; retrieve(从缓存中恢复当前路由) -&gt; store(存储当前路由缓存，这里handle参数为null，应该是清理脏数据)","link":"/2022/10/30/ng-route-reuse/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"angular","slug":"angular","link":"/tags/angular/"},{"name":"路由缓存","slug":"路由缓存","link":"/tags/%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98/"}],"categories":[{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"}],"pages":[]}